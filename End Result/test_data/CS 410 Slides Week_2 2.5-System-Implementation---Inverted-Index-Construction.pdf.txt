system implementation inverted index construction cheng xiang department of computer science university of illinois at urbana champaign system implementation inverted index construction big textdata small relevant data search engine recommend er system text access 11 recommendation text retrieval problem 10 web search user natural language content analysis text retrieval methods system implementation evaluation vector space model probabilistic model feedback constructing inverted index the main difficulty is to build huge index with limited memory memory based methods not usable for large collections sort based methods step collect local term id docid fr eq tuples step pairwise merge runs step output inverted file sort based in version term lexicon the campaign news docid lexicon doc 11 doc 22 doc 33 doc doc doc 3001132123111223234221300333001 sort by docid parse count 1131222122431531621299313001 sort by term id sort 113122152163130032125000299150003001 merge sort all info about term inverted index compression in general leverage skewed distribution of values and use variable length encoding compression small numbers tend to occur far more frequently than large numbers why fewer bits for small high frequency integers at the cost of more bits for large integers docid compression feasible due to sequential access methods binary code nary code code integer compression methods binary equal length coding nary is coded as one bits followed by eg 3110511110 codex nary code for log followed by uniform code for log in log xb its eg 3101511001 code same as code but replace the nary prefix with code eg 31001510101 un compress inverted index decoding of encoded integers decoding first decode the nary part let value bek read more bits decode them as binary code let value berthe value of the encoded number is kr decode docid encoded using gap de codex to obtain docid then de codex and add the recovered value to the docid just obtained previous docid
